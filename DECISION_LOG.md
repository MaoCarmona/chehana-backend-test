# Decision Log - Chehana Backend Test

Este documento explica las decisiones t√©cnicas tomadas durante el desarrollo del sistema de gesti√≥n de tareas.

## üìã √çndice

1. [Arquitectura General](#arquitectura-general)
2. [Stack Tecnol√≥gico](#stack-tecnol√≥gico)
3. [Estructura de Base de Datos](#estructura-de-base-de-datos)
4. [Autenticaci√≥n y Autorizaci√≥n](#autenticaci√≥n-y-autorizaci√≥n)
5. [Patrones de Dise√±o](#patrones-de-dise√±o)
6. [Testing](#testing)
7. [DevOps y Deployment](#devops-y-deployment)
8. [Decisiones de Rendimiento](#decisiones-de-rendimiento)

## üèóÔ∏è Arquitectura General

### Clean Architecture

**Decisi√≥n**: Implementar Clean Architecture con separaci√≥n clara de capas.

**Razones**:
- ‚úÖ **Mantenibilidad**: Separaci√≥n clara de responsabilidades
- ‚úÖ **Testabilidad**: F√°cil testeo unitario de cada capa
- ‚úÖ **Escalabilidad**: Permite agregar nuevas funcionalidades sin afectar el core
- ‚úÖ **Independencia**: El dominio no depende de frameworks o bases de datos

**Estructura Implementada**:
```
Domain (Entidades + Repositorios abstractos)
    ‚Üì
Application (Casos de uso + DTOs + Servicios)
    ‚Üì
Infrastructure (Implementaciones + API + DB)
```

**Alternativas Consideradas**:
- MVR tradicional: Descartado por acoplamiento
- Arquitectura por capas simple: Descartado por mezcla de responsabilidades

## üõ†Ô∏è Stack Tecnol√≥gico

### FastAPI como Framework Principal

**Decisi√≥n**: Usar FastAPI como framework web principal.

**Razones**:
- ‚úÖ **Performance**: Uno de los frameworks m√°s r√°pidos para Python
- ‚úÖ **Tipado**: Soporte nativo para type hints
- ‚úÖ **Documentaci√≥n autom√°tica**: Swagger/OpenAPI integrado
- ‚úÖ **Validaci√≥n**: Pydantic integrado para validaci√≥n de datos
- ‚úÖ **Async/Await**: Soporte nativo para programaci√≥n as√≠ncrona

**Alternativas Consideradas**:
- Django REST Framework: M√°s pesado, no async nativo
- Flask: Requiere m√°s configuraci√≥n manual

### PostgreSQL como Base de Datos

**Decisi√≥n**: Usar PostgreSQL como base de datos principal.

**Razones**:
- ‚úÖ **ACID**: Garant√≠as de transacciones
- ‚úÖ **Relaciones**: Soporte completo para relaciones complejas
- ‚úÖ **UUID**: Soporte nativo para UUIDs
- ‚úÖ **JSON**: Soporte para datos semi-estructurados
- ‚úÖ **Escalabilidad**: Probado en producci√≥n a gran escala

**Alternativas Consideradas**:
- MongoDB: Descartado por necesidad de relaciones estrictas
- SQLite: Descartado por limitaciones de concurrencia

### SQLAlchemy con Async

**Decisi√≥n**: Usar SQLAlchemy 2.0 con soporte as√≠ncrono.

**Razones**:
- ‚úÖ **ORM Maduro**: Ampliamente probado y documentado
- ‚úÖ **Async Support**: Soporte nativo para operaciones as√≠ncronas
- ‚úÖ **Type Safety**: Excelente integraci√≥n con type hints
- ‚úÖ **Migration**: Alembic integrado para migraciones

**Implementaci√≥n**:
```python
# Configuraci√≥n async
async_engine = create_async_engine(database_url)
AsyncSessionLocal = async_sessionmaker(bind=async_engine)
```

## üóÉÔ∏è Estructura de Base de Datos

### Uso de UUIDs como Primary Keys

**Decisi√≥n**: Usar UUIDs en lugar de IDs incrementales.

**Razones**:
- ‚úÖ **Seguridad**: No expone informaci√≥n sobre volumen de datos
- ‚úÖ **Distribuci√≥n**: Permite sharding sin conflictos
- ‚úÖ **APIs**: URLs m√°s seguras
- ‚úÖ **Integraci√≥n**: Facilita integraciones con sistemas externos

**Implementaci√≥n**:
```python
id: Mapped[uuid.UUID] = mapped_column(
    UUID(as_uuid=True), 
    primary_key=True, 
    default=uuid.uuid4
)
```

### Relaciones y Constraints

**Decisi√≥n**: Usar foreign keys con cascades espec√≠ficos.

**Razones**:
- ‚úÖ **Integridad**: Garantiza consistencia de datos
- ‚úÖ **Performance**: √çndices autom√°ticos en FKs
- ‚úÖ **Mantenimiento**: Cascades autom√°ticos apropiados

**Implementaci√≥n**:
```python
# Cascade DELETE para tareas cuando se elimina lista
tasks: Mapped[List["TaskModel"]] = relationship(
    "TaskModel", 
    back_populates="task_list", 
    cascade="all, delete-orphan"
)

# SET NULL para asignaciones cuando se elimina usuario
assigned_to: Mapped[uuid.UUID] = mapped_column(
    UUID(as_uuid=True), 
    ForeignKey("users.id", ondelete="SET NULL"), 
    nullable=True
)
```

## üîê Autenticaci√≥n y Autorizaci√≥n

### JWT para Autenticaci√≥n

**Decisi√≥n**: Implementar autenticaci√≥n basada en JWT.

**Razones**:
- ‚úÖ **Stateless**: No requiere almacenamiento de sesi√≥n
- ‚úÖ **Escalabilidad**: F√°cil escalamiento horizontal
- ‚úÖ **Performance**: No consultas de sesi√≥n en cada request
- ‚úÖ **Est√°ndar**: RFC 7519, ampliamente soportado

**Configuraci√≥n**:
```python
ACCESS_TOKEN_EXPIRE_MINUTES = 30
ALGORITHM = "HS256"
```

**Alternativas Consideradas**:
- Sessions: Descartado por limitaciones de escalabilidad
- OAuth2: Innecesario para este scope

### bcrypt para Hashing de Passwords

**Decisi√≥n**: Usar bcrypt para hashear contrase√±as.

**Razones**:
- ‚úÖ **Seguridad**: Resistente a ataques de fuerza bruta
- ‚úÖ **Salt autom√°tico**: Salt √∫nico por password
- ‚úÖ **Configurable**: Work factor ajustable
- ‚úÖ **Est√°ndar**: Ampliamente usado y auditado

### Autorizaci√≥n Basada en Ownership

**Decisi√≥n**: Implementar autorizaci√≥n basada en propietario de recursos.

**Razones**:
- ‚úÖ **Simplicidad**: Modelo simple y comprensible
- ‚úÖ **Seguridad**: Cada usuario solo ve sus recursos
- ‚úÖ **Performance**: Filtros eficientes por owner_id

**Implementaci√≥n**:
```python
# Solo el propietario puede ver/modificar sus listas
if task_list.owner_id != user_id:
    raise AuthorizationError("No autorizado")
```

## üéØ Patrones de Dise√±o

### Repository Pattern

**Decisi√≥n**: Implementar Repository Pattern para abstracci√≥n de datos.

**Razones**:
- ‚úÖ **Testabilidad**: F√°cil mocking para tests
- ‚úÖ **Flexibilidad**: Cambio de implementaci√≥n sin afectar l√≥gica
- ‚úÖ **Separaci√≥n**: Dominio independiente de infraestructura

**Implementaci√≥n**:
```python
# Contrato abstracto
class UserRepository(ABC):
    @abstractmethod
    async def create(self, user: User) -> User:
        pass

# Implementaci√≥n concreta
class SQLAlchemyUserRepository(UserRepository):
    async def create(self, user: User) -> User:
        # Implementaci√≥n espec√≠fica
```

### Dependency Injection

**Decisi√≥n**: Usar el sistema de DI nativo de FastAPI.

**Razones**:
- ‚úÖ **Integraci√≥n**: Nativo en FastAPI
- ‚úÖ **Performance**: Resoluci√≥n eficiente
- ‚úÖ **Simplicidad**: Sintaxis clara y concisa

**Implementaci√≥n**:
```python
def get_user_repository(
    session: AsyncSession = Depends(get_database_session),
) -> SQLAlchemyUserRepository:
    return SQLAlchemyUserRepository(session)
```

### Use Case Pattern

**Decisi√≥n**: Encapsular l√≥gica de negocio en casos de uso.

**Razones**:
- ‚úÖ **Single Responsibility**: Cada caso de uso tiene una responsabilidad
- ‚úÖ **Testabilidad**: F√°cil testeo de l√≥gica de negocio
- ‚úÖ **Reutilizaci√≥n**: Casos de uso reutilizables

## üß™ Testing

### pytest como Framework de Testing

**Decisi√≥n**: Usar pytest para testing.

**Razones**:
- ‚úÖ **Fixtures**: Sistema de fixtures flexible
- ‚úÖ **Parametrizaci√≥n**: Tests parametrizados f√°ciles
- ‚úÖ **Plugins**: Amplio ecosistema de plugins
- ‚úÖ **Async**: Soporte para testing as√≠ncrono

### Cobertura de 75%

**Decisi√≥n**: Establecer objetivo m√≠nimo de 75% de cobertura.

**Razones**:
- ‚úÖ **Calidad**: Balance entre calidad y tiempo de desarrollo
- ‚úÖ **Pragm√°tico**: No 100% que puede ser contraproducente
- ‚úÖ **Enfoque**: Concentrarse en l√≥gica cr√≠tica

**Configuraci√≥n**:
```ini
[tool:pytest]
addopts = --cov=app --cov-fail-under=75
```

### Testing por Capas

**Decisi√≥n**: Separar tests por tipo (unit/integration).

**Razones**:
- ‚úÖ **Velocidad**: Tests unitarios r√°pidos
- ‚úÖ **Aislamiento**: Tests unitarios aislados
- ‚úÖ **Confiabilidad**: Tests de integraci√≥n para flujos completos

**Estructura**:
```
tests/
‚îú‚îÄ‚îÄ unit/          # Tests r√°pidos, sin dependencias
‚îî‚îÄ‚îÄ integration/   # Tests con BD, m√°s lentos
```

## üöÄ DevOps y Deployment

### Docker Multistage

**Decisi√≥n**: Usar Dockerfile multistage para optimizaci√≥n.

**Razones**:
- ‚úÖ **Tama√±o**: Im√°genes m√°s peque√±as
- ‚úÖ **Seguridad**: Sin herramientas de build en producci√≥n
- ‚úÖ **Performance**: Mejores tiempos de build

**Implementaci√≥n**:
```dockerfile
# Etapa 1: Dependencias
FROM python:3.11-slim as dependencies
RUN pip install -r requirements.txt

# Etapa 2: Aplicaci√≥n
FROM python:3.11-slim as application
COPY --from=dependencies /usr/local/lib/python3.11/site-packages
```

### Docker Compose para Desarrollo

**Decisi√≥n**: Incluir docker-compose.yml completo.

**Razones**:
- ‚úÖ **Simplicidad**: Un comando para levantar todo
- ‚úÖ **Consistencia**: Mismo entorno en todos lados
- ‚úÖ **Servicios**: BD, email server incluidos

**Servicios incluidos**:
- App (FastAPI)
- PostgreSQL
- PgAdmin (administraci√≥n)
- MailHog (testing de emails)

### Alembic para Migraciones

**Decisi√≥n**: Usar Alembic para migraciones de BD.

**Razones**:
- ‚úÖ **Versionado**: Control de versiones de esquema
- ‚úÖ **Rollback**: Capacidad de revertir cambios
- ‚úÖ **Automatizaci√≥n**: Generaci√≥n autom√°tica de migraciones

## ‚ö° Decisiones de Rendimiento

### Async/Await en Toda la Stack

**Decisi√≥n**: Usar programaci√≥n as√≠ncrona en toda la aplicaci√≥n.

**Razones**:
- ‚úÖ **Concurrencia**: Mejor manejo de m√∫ltiples requests
- ‚úÖ **Escalabilidad**: Menos recursos por connection
- ‚úÖ **Performance**: Mejor utilizaci√≥n de CPU

**Implementaci√≥n**:
```python
# Repository async
async def create(self, user: User) -> User:
    # Operaci√≥n as√≠ncrona
    
# Use case async
async def register_user(self, request: UserRegisterRequest):
    # L√≥gica as√≠ncrona
    
# Endpoint async
async def register_user(request: UserRegisterRequest):
    # Handler as√≠ncrono
```

### Lazy Loading de Relaciones

**Decisi√≥n**: Usar lazy loading por defecto, eager cuando sea necesario.

**Razones**:
- ‚úÖ **Performance**: Evita N+1 queries
- ‚úÖ **Memoria**: Carga solo datos necesarios
- ‚úÖ **Flexibilidad**: Eager loading donde se requiera

### Connection Pooling

**Decisi√≥n**: Configurar pool de conexiones para BD.

**Razones**:
- ‚úÖ **Performance**: Reutilizaci√≥n de conexiones
- ‚úÖ **Recursos**: L√≠mite de conexiones concurrentes
- ‚úÖ **Estabilidad**: Previene agotamiento de conexiones

## üîß Herramientas de Desarrollo

### Black + isort para Formateo

**Decisi√≥n**: Usar Black como formateador principal con isort.

**Razones**:
- ‚úÖ **Consistencia**: Formato consistente sin discusiones
- ‚úÖ **Automatizaci√≥n**: Formateo autom√°tico
- ‚úÖ **Adopci√≥n**: Est√°ndar de facto en Python

### flake8 + ruff para Linting

**Decisi√≥n**: Combinar flake8 con ruff para linting.

**Razones**:
- ‚úÖ **Calidad**: Detecci√≥n de problemas potenciales
- ‚úÖ **Est√°ndares**: Adherencia a PEP 8
- ‚úÖ **Performance**: ruff es extremadamente r√°pido

### Pre-commit Hooks (Recomendado)

**Decisi√≥n**: Recomendar pre-commit hooks.

**Razones**:
- ‚úÖ **Prevenci√≥n**: Detecta problemas antes del commit
- ‚úÖ **Automatizaci√≥n**: Ejecuta herramientas autom√°ticamente
- ‚úÖ **Calidad**: Mantiene est√°ndares de c√≥digo

## üìä M√©tricas y Monitoreo

### Health Checks

**Decisi√≥n**: Implementar endpoints de health check.

**Razones**:
- ‚úÖ **Monitoring**: Facilita monitoreo automatizado
- ‚úÖ **Deployment**: Validaci√≥n de deployments
- ‚úÖ **Debugging**: Informaci√≥n de estado del sistema

### Logging Estructurado

**Decisi√≥n**: Usar logging estructurado.

**Razones**:
- ‚úÖ **Debugging**: Facilita debugging en producci√≥n
- ‚úÖ **Monitoring**: Integraci√≥n con sistemas de monitoreo
- ‚úÖ **Trazabilidad**: Seguimiento de requests

## üîÆ Decisiones Futuras

### Cosas a Considerar para Producci√≥n

1. **Rate Limiting**: Implementar limitaci√≥n de requests
2. **Caching**: Redis para caching de queries frecuentes
3. **Observability**: OpenTelemetry para tracing
4. **Security**: Implementar security headers
5. **Performance**: Profiling y optimizaci√≥n de queries
6. **Backup**: Estrategia de backup de BD
7. **CI/CD**: Pipeline automatizado
8. **Documentation**: Documentaci√≥n de arquitectura

### Posibles Mejoras

1. **Microservicios**: Separar en servicios m√°s peque√±os
2. **Event Sourcing**: Para auditoria completa
3. **CQRS**: Separar commands de queries
4. **GraphQL**: API m√°s flexible para frontend
5. **WebSockets**: Notificaciones en tiempo real

---

Este documento ser√° actualizado conforme evolucione el proyecto y se tomen nuevas decisiones t√©cnicas. 